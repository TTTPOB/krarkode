// @generated
// This file is generated by scripts/generate-data-explorer-types.mjs from resources/data_explorer.json.
export interface DataExplorerTypes {
    array_selection?:                    ArraySelection;
    backend_state?:                      BackendState;
    code_syntax_name?:                   string;
    code_syntax_name_result?:            CodeSyntaxNameResult;
    column_display_type?:                ColumnDisplayTypeElement;
    column_filter?:                      ColumnFilterElement;
    column_filter_params?:               ColumnFilterParamsObject;
    column_filter_type?:                 ColumnFilterTypeEnum;
    column_filter_type_support_status?:  ColumnFilterTypeSupportStatusElement;
    column_frequency_table?:             ColumnFrequencyTable;
    column_frequency_table_params?:      ColumnFrequencyTableParams;
    column_histogram?:                   ColumnHistogram;
    column_histogram_params?:            ColumnHistogramParams;
    column_profile_params?:              ColumnProfileParams;
    column_profile_request?:             ColumnProfileRequest;
    column_profile_result?:              ColumnProfileResult;
    column_profile_spec?:                ColumnProfileSpecElement;
    column_profile_type?:                ColumnProfileTypeEnum;
    column_profile_type_support_status?: ColumnProfileTypeSupportStatusElement;
    column_quantile_value?:              ColumnQuantileValueElement;
    column_schema?:                      ColumnSchema;
    column_selection?:                   ColumnSelection;
    column_sort_key?:                    ColumnSortKeyElement;
    column_summary_stats?:               SummaryStats;
    column_value?:                       number | string;
    convert_to_code_features?:           ConvertToCode;
    convert_to_code_params?:             ConvertToCodeParams;
    converted_code?:                     ConvertedCode;
    data_selection_cell_indices?:        DataSelectionCellIndicesObject;
    data_selection_cell_range?:          DataSelectionCellRangeObject;
    data_selection_indices?:             DataSelectionIndicesObject;
    data_selection_range?:               DataSelectionRangeObject;
    data_selection_single_cell?:         DataSelectionSingleCellObject;
    dataset_import_options?:             DatasetImportOptions;
    export_data_selection_features?:     ExportDataSelection;
    export_data_selection_params?:       ExportDataSelectionParams;
    export_format?:                      ExportFormatElement;
    exported_data?:                      ExportedData;
    filter_between?:                     FilterBetweenObject;
    filter_comparison?:                  FilterComparisonObject;
    filter_match_data_types?:            FilterMatchDataTypesObject;
    filter_result?:                      FilterResult;
    filter_set_membership?:              FilterSetMembershipObject;
    filter_text_search?:                 FilterTextSearchObject;
    format_options?:                     FormatOptions;
    get_column_profiles_features?:       GetColumnProfiles;
    get_column_profiles_params?:         GetColumnProfilesParams;
    get_data_values_params?:             GetDataValuesParams;
    get_row_labels_params?:              GetRowLabelsParams;
    get_schema_params?:                  GetSchemaParams;
    open_dataset_params?:                OpenDatasetParams;
    open_dataset_result?:                OpenDatasetResult;
    row_filter?:                         RowFilterElement;
    row_filter_params?:                  RowFilterParamsObject;
    row_filter_type?:                    RowFilterTypeEnum;
    row_filter_type_support_status?:     RowFilterTypeSupportStatusElement;
    search_schema_features?:             SearchSchema;
    search_schema_params?:               SearchSchemaParams;
    search_schema_result?:               SearchSchemaResult;
    set_column_filters_features?:        SetColumnFilters;
    set_column_filters_params?:          SetColumnFiltersParams;
    set_dataset_import_options_params?:  SetDatasetImportOptionsParams;
    set_dataset_import_options_result?:  SetDatasetImportOptionsResult;
    set_row_filters_features?:           SetRowFilters;
    set_row_filters_params?:             SetRowFiltersParams;
    set_sort_columns_features?:          SetSortColumns;
    set_sort_columns_params?:            SetSortColumnsParams;
    summary_stats_boolean?:              BooleanStats;
    summary_stats_date?:                 DateStats;
    summary_stats_datetime?:             DatetimeStats;
    summary_stats_number?:               NumberStats;
    summary_stats_other?:                OtherStats;
    summary_stats_string?:               StringStats;
    support_status?:                     SupportStatus;
    supported_features?:                 SupportedFeatures;
    table_data?:                         TableData;
    table_row_labels?:                   TableRowLabels;
    table_schema?:                       TableSchema;
    table_selection?:                    TableSelectionObject;
    table_shape?:                        TableShape;
    text_search_type?:                   TextSearchTypeEnum;
    [property: string]: any;
}

/**
 * Union of selection specifications for array_selection
 *
 * A contiguous selection bounded by inclusive start and end indices
 *
 * A selection defined by a sequence of indices to include
 */
export interface ArraySelection {
    /**
     * The starting selected index (inclusive)
     */
    first_index?: number;
    /**
     * The final selected index (inclusive)
     */
    last_index?: number;
    /**
     * The selected indices
     */
    indices?: number[];
    [property: string]: any;
}

/**
 * The current backend state for the data explorer
 */
export interface BackendState {
    /**
     * The currently applied column filters
     */
    column_filters: ColumnFilterElement[];
    /**
     * Optional flag allowing backend to report that it is unable to serve requests. This
     * parameter may change.
     */
    connected?: boolean;
    /**
     * Variable name or other string to display for tab name in UI
     */
    display_name: string;
    /**
     * Optional experimental parameter to provide an explanation when connected=false. This
     * parameter may change.
     */
    error_message?: string;
    /**
     * Indicates whether table has row labels or whether rows should be labeled by ordinal
     * position
     */
    has_row_labels: boolean;
    /**
     * The currently applied row filters
     */
    row_filters: RowFilterElement[];
    /**
     * The currently applied column sort keys
     */
    sort_keys: ColumnSortKeyElement[];
    /**
     * The features currently supported by the backend instance
     */
    supported_features: SupportedFeatures;
    /**
     * Number of rows and columns in table with row/column filters applied
     */
    table_shape: TableShape;
    /**
     * Number of rows and columns in table without any filters applied
     */
    table_unfiltered_shape: TableShape;
    [property: string]: any;
}

/**
 * A filter that selects a subset of columns by name, type, or other criteria
 */
export interface ColumnFilterElement {
    /**
     * Type of column filter to apply
     */
    filter_type: ColumnFilterTypeEnum;
    /**
     * Parameters for column filter
     */
    params: ColumnFilterParamsObject;
    [property: string]: any;
}

/**
 * Type of column filter to apply
 *
 * Type of column filter
 */
export enum ColumnFilterTypeEnum {
    MatchDataTypes = "match_data_types",
    TextSearch = "text_search",
}

/**
 * Parameters for column filter
 *
 * Union of column filter type-specific parameters
 *
 * Parameters for the 'search' filter type
 *
 * Parameters for the 'match_data_types' filter type
 */
export interface ColumnFilterParamsObject {
    /**
     * If true, do a case-sensitive search, otherwise case-insensitive
     */
    case_sensitive?: boolean;
    /**
     * Type of search to perform
     */
    search_type?: TextSearchTypeEnum;
    /**
     * String value/regex to search for
     */
    term?: string;
    /**
     * Column display types to match
     */
    display_types?: ColumnDisplayTypeElement[];
    [property: string]: any;
}

/**
 * Canonical Positron display name of data type
 */
export enum ColumnDisplayTypeElement {
    Array = "array",
    Boolean = "boolean",
    Date = "date",
    Datetime = "datetime",
    Decimal = "decimal",
    Floating = "floating",
    Integer = "integer",
    Interval = "interval",
    Object = "object",
    String = "string",
    Struct = "struct",
    Time = "time",
    Unknown = "unknown",
}

/**
 * Type of search to perform
 *
 * Type of string text search filter to perform
 */
export enum TextSearchTypeEnum {
    Contains = "contains",
    EndsWith = "ends_with",
    NotContains = "not_contains",
    RegexMatch = "regex_match",
    StartsWith = "starts_with",
}

/**
 * Specifies a table row filter based on a single column's values
 */
export interface RowFilterElement {
    /**
     * Column to apply filter to
     */
    column_schema: ColumnSchema;
    /**
     * The binary condition to use to combine with preceding row filters
     */
    condition: Condition;
    /**
     * Optional error message when the filter is invalid
     */
    error_message?: string;
    /**
     * Unique identifier for this filter
     */
    filter_id: string;
    /**
     * Type of row filter to apply
     */
    filter_type: RowFilterTypeEnum;
    /**
     * Whether the filter is valid and supported by the backend, if undefined then true
     */
    is_valid?: boolean;
    /**
     * The row filter type-specific parameters
     */
    params?: RowFilterParamsObject;
    [property: string]: any;
}

/**
 * Column to apply filter to
 *
 * Schema for a column in a table
 */
export interface ColumnSchema {
    /**
     * Schema of nested child types
     */
    children?: ColumnSchema[];
    /**
     * The position of the column within the table without any column filters
     */
    column_index: number;
    /**
     * Display label for column (e.g., from R's label attribute)
     */
    column_label?: string;
    /**
     * Name of column as UTF-8 string
     */
    column_name: string;
    /**
     * Column annotation / description
     */
    description?: string;
    /**
     * Precision for decimal types
     */
    precision?: number;
    /**
     * Scale for decimal types
     */
    scale?: number;
    /**
     * Time zone for timestamp with time zone
     */
    timezone?: string;
    /**
     * Canonical Positron display name of data type
     */
    type_display: ColumnDisplayTypeElement;
    /**
     * Exact name of data type used by underlying table
     */
    type_name: string;
    /**
     * Size parameter for fixed-size types (list, binary)
     */
    type_size?: number;
    [property: string]: any;
}

/**
 * The binary condition to use to combine with preceding row filters
 */
export enum Condition {
    And = "and",
    Or = "or",
}

/**
 * Type of row filter to apply
 *
 * Type of row filter
 */
export enum RowFilterTypeEnum {
    Between = "between",
    Compare = "compare",
    IsEmpty = "is_empty",
    IsFalse = "is_false",
    IsNull = "is_null",
    IsTrue = "is_true",
    NotBetween = "not_between",
    NotEmpty = "not_empty",
    NotNull = "not_null",
    Search = "search",
    SetMembership = "set_membership",
}

/**
 * The row filter type-specific parameters
 *
 * Union of row filter parameters
 *
 * Parameters for the 'between' and 'not_between' filter types
 *
 * Parameters for the 'compare' filter type
 *
 * Parameters for the 'search' filter type
 *
 * Parameters for the 'set_membership' filter type
 */
export interface RowFilterParamsObject {
    /**
     * The lower limit for filtering
     */
    left_value?: string;
    /**
     * The upper limit for filtering
     */
    right_value?: string;
    /**
     * String representation of a binary comparison
     */
    op?: Op;
    /**
     * A stringified column value for a comparison filter
     */
    value?: string;
    /**
     * If true, do a case-sensitive search, otherwise case-insensitive
     */
    case_sensitive?: boolean;
    /**
     * Type of search to perform
     */
    search_type?: TextSearchTypeEnum;
    /**
     * String value/regex to search for
     */
    term?: string;
    /**
     * Filter by including only values passed (true) or excluding (false)
     */
    inclusive?: boolean;
    /**
     * Array of values for a set membership filter
     */
    values?: string[];
    [property: string]: any;
}

/**
 * String representation of a binary comparison
 */
export enum Op {
    Empty = "=",
    Fluffy = "<=",
    Op = "!=",
    Purple = "<",
    Sticky = ">=",
    Tentacled = ">",
}

/**
 * Specifies a column to sort by
 */
export interface ColumnSortKeyElement {
    /**
     * Sort order, ascending (true) or descending (false)
     */
    ascending: boolean;
    /**
     * Column index (absolute, relative to unfiltered table) to sort by
     */
    column_index: number;
    [property: string]: any;
}

/**
 * The features currently supported by the backend instance
 *
 * For each field, returns flags indicating supported features
 */
export interface SupportedFeatures {
    /**
     * Support for 'convert_to_code' RPC and its features
     */
    convert_to_code: ConvertToCode;
    /**
     * Support for 'export_data_selection' RPC and its features
     */
    export_data_selection: ExportDataSelection;
    /**
     * Support for 'get_column_profiles' RPC and its features
     */
    get_column_profiles: GetColumnProfiles;
    /**
     * Support for 'search_schema' RPC and its features
     */
    search_schema: SearchSchema;
    /**
     * Support ofr 'set_column_filters' RPC and its features
     */
    set_column_filters: SetColumnFilters;
    /**
     * Support for 'set_row_filters' RPC and its features
     */
    set_row_filters: SetRowFilters;
    /**
     * Support for 'set_sort_columns' RPC and its features
     */
    set_sort_columns: SetSortColumns;
    [property: string]: any;
}

/**
 * Support for 'convert_to_code' RPC and its features
 *
 * Feature flags for convert to code RPC
 */
export interface ConvertToCode {
    /**
     * The syntaxes for converted code
     */
    code_syntaxes?: string[];
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    [property: string]: any;
}

/**
 * The support status for this RPC method
 *
 * The support status of the RPC method
 *
 * The support status for this column profile type
 *
 * The support status for this column filter type
 *
 * The support status for this row filter type
 *
 * Whether AND/OR filter conditions are supported
 */
export enum SupportStatus {
    Supported = "supported",
    Unsupported = "unsupported",
}

/**
 * Support for 'export_data_selection' RPC and its features
 *
 * Feature flags for 'export_data_selction' RPC
 */
export interface ExportDataSelection {
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    /**
     * Export formats supported
     */
    supported_formats: ExportFormatElement[];
    [property: string]: any;
}

/**
 * Exported data format
 *
 * The exported data format
 */
export enum ExportFormatElement {
    CSV = "csv",
    HTML = "html",
    Tsv = "tsv",
}

/**
 * Support for 'get_column_profiles' RPC and its features
 *
 * Feature flags for 'get_column_profiles' RPC
 */
export interface GetColumnProfiles {
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    /**
     * A list of supported types
     */
    supported_types: ColumnProfileTypeSupportStatusElement[];
    [property: string]: any;
}

/**
 * Support status for a given column profile type
 */
export interface ColumnProfileTypeSupportStatusElement {
    /**
     * The type of analytical column profile
     */
    profile_type: ColumnProfileTypeEnum;
    /**
     * The support status for this column profile type
     */
    support_status: SupportStatus;
    [property: string]: any;
}

/**
 * The type of analytical column profile
 *
 * Type of analytical column profile
 *
 * Type of column profile
 */
export enum ColumnProfileTypeEnum {
    LargeFrequencyTable = "large_frequency_table",
    LargeHistogram = "large_histogram",
    NullCount = "null_count",
    SmallFrequencyTable = "small_frequency_table",
    SmallHistogram = "small_histogram",
    SummaryStats = "summary_stats",
}

/**
 * Support for 'search_schema' RPC and its features
 *
 * Feature flags for 'search_schema' RPC
 */
export interface SearchSchema {
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    /**
     * A list of supported types
     */
    supported_types: ColumnFilterTypeSupportStatusElement[];
    [property: string]: any;
}

/**
 * Support status for a column filter type
 */
export interface ColumnFilterTypeSupportStatusElement {
    /**
     * Type of column filter
     */
    column_filter_type: ColumnFilterTypeEnum;
    /**
     * The support status for this column filter type
     */
    support_status: SupportStatus;
    [property: string]: any;
}

/**
 * Support ofr 'set_column_filters' RPC and its features
 *
 * Feature flags for 'set_column_filters' RPC
 */
export interface SetColumnFilters {
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    /**
     * A list of supported types
     */
    supported_types: ColumnFilterTypeSupportStatusElement[];
    [property: string]: any;
}

/**
 * Support for 'set_row_filters' RPC and its features
 *
 * Feature flags for 'set_row_filters' RPC
 */
export interface SetRowFilters {
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    /**
     * A list of supported types
     */
    supported_types: RowFilterTypeSupportStatusElement[];
    /**
     * Whether AND/OR filter conditions are supported
     */
    supports_conditions: SupportStatus;
    [property: string]: any;
}

/**
 * Support status for a row filter type
 */
export interface RowFilterTypeSupportStatusElement {
    /**
     * Type of row filter
     */
    row_filter_type: RowFilterTypeEnum;
    /**
     * The support status for this row filter type
     */
    support_status: SupportStatus;
    [property: string]: any;
}

/**
 * Support for 'set_sort_columns' RPC and its features
 *
 * Feature flags for 'set_sort_columns' RPC
 */
export interface SetSortColumns {
    /**
     * The support status for this RPC method
     */
    support_status: SupportStatus;
    [property: string]: any;
}

/**
 * Number of rows and columns in table with row/column filters applied
 *
 * Provides number of rows and columns in a table
 *
 * Number of rows and columns in table without any filters applied
 */
export interface TableShape {
    /**
     * Number of columns in the table
     */
    num_columns: number;
    /**
     * Numbers of rows in the table
     */
    num_rows: number;
    [property: string]: any;
}

/**
 * Syntax to use for code conversion
 */
export interface CodeSyntaxNameResult {
    /**
     * The name of the code syntax, eg, pandas, polars, dplyr, etc.
     */
    code_syntax_name: string;
    [property: string]: any;
}

/**
 * Result from a frequency_table profile request
 *
 * Results from large frequency_table request
 *
 * Results from small frequency_table request
 */
export interface ColumnFrequencyTable {
    /**
     * Counts of top values
     */
    counts: number[];
    /**
     * Number of other values not accounted for in counts, excluding nulls/NA values. May be
     * omitted
     */
    other_count?: number;
    /**
     * The formatted top values
     */
    values: Array<number | string>;
    [property: string]: any;
}

/**
 * Parameters for a frequency_table profile request
 */
export interface ColumnFrequencyTableParams {
    /**
     * Number of most frequently-occurring values to return. The K in TopK
     */
    limit: number;
    [property: string]: any;
}

/**
 * Result from a histogram profile request
 *
 * Results from large histogram request
 *
 * Results from small histogram request
 */
export interface ColumnHistogram {
    /**
     * Absolute count of values in each histogram bin
     */
    bin_counts: number[];
    /**
     * String-formatted versions of the bin edges, there are N + 1 where N is the number of bins
     */
    bin_edges: string[];
    /**
     * Sample quantiles that were also requested
     */
    quantiles: ColumnQuantileValueElement[];
    [property: string]: any;
}

/**
 * An exact or approximate quantile value from a column
 */
export interface ColumnQuantileValueElement {
    /**
     * Whether value is exact or approximate (computed from binned data or sketches)
     */
    exact: boolean;
    /**
     * Quantile number; a number between 0 and 1
     */
    q: number;
    /**
     * Stringified quantile value
     */
    value: string;
    [property: string]: any;
}

/**
 * Parameters for a column histogram profile request
 */
export interface ColumnHistogramParams {
    /**
     * Method for determining number of bins
     */
    method: Method;
    /**
     * Maximum number of bins in the computed histogram.
     */
    num_bins: number;
    /**
     * Sample quantiles (numbers between 0 and 1) to compute along with the histogram
     */
    quantiles?: number[];
    [property: string]: any;
}

/**
 * Method for determining number of bins
 */
export enum Method {
    Fixed = "fixed",
    FreedmanDiaconis = "freedman_diaconis",
    Scott = "scott",
    Sturges = "sturges",
}

/**
 * Extra parameters for different profile types
 *
 * Parameters for a column histogram profile request
 *
 * Parameters for a frequency_table profile request
 */
export interface ColumnProfileParams {
    /**
     * Method for determining number of bins
     */
    method?: Method;
    /**
     * Maximum number of bins in the computed histogram.
     */
    num_bins?: number;
    /**
     * Sample quantiles (numbers between 0 and 1) to compute along with the histogram
     */
    quantiles?: number[];
    /**
     * Number of most frequently-occurring values to return. The K in TopK
     */
    limit?: number;
    [property: string]: any;
}

/**
 * A single column profile request
 */
export interface ColumnProfileRequest {
    /**
     * The column index (absolute, relative to unfiltered table) to profile
     */
    column_index: number;
    /**
     * Column profiles needed
     */
    profiles: ColumnProfileSpecElement[];
    [property: string]: any;
}

/**
 * Parameters for a single column profile for a request for profiles
 */
export interface ColumnProfileSpecElement {
    /**
     * Extra parameters for different profile types
     */
    params?: ColumnProfileParams;
    /**
     * Type of column profile
     */
    profile_type: ColumnProfileTypeEnum;
    [property: string]: any;
}

/**
 * Result of computing column profile
 */
export interface ColumnProfileResult {
    /**
     * Results from large frequency_table request
     */
    large_frequency_table?: ColumnFrequencyTable;
    /**
     * Results from large histogram request
     */
    large_histogram?: ColumnHistogram;
    /**
     * Result from null_count request
     */
    null_count?: number;
    /**
     * Results from small frequency_table request
     */
    small_frequency_table?: ColumnFrequencyTable;
    /**
     * Results from small histogram request
     */
    small_histogram?: ColumnHistogram;
    /**
     * Results from summary_stats request
     */
    summary_stats?: SummaryStats;
    [property: string]: any;
}

/**
 * Results from summary_stats request
 *
 * Profile result containing summary stats for a column based on the data type
 */
export interface SummaryStats {
    /**
     * Statistics for a boolean data type
     */
    boolean_stats?: BooleanStats;
    /**
     * Statistics for a date data type
     */
    date_stats?: DateStats;
    /**
     * Statistics for a datetime data type
     */
    datetime_stats?: DatetimeStats;
    /**
     * Statistics for a numeric data type
     */
    number_stats?: NumberStats;
    /**
     * Summary statistics for any other data types
     */
    other_stats?: OtherStats;
    /**
     * Statistics for a string-like data type
     */
    string_stats?: StringStats;
    /**
     * Canonical Positron display name of data type
     */
    type_display: ColumnDisplayTypeElement;
    [property: string]: any;
}

/**
 * Statistics for a boolean data type
 */
export interface BooleanStats {
    /**
     * The number of non-null false values
     */
    false_count: number;
    /**
     * The number of non-null true values
     */
    true_count: number;
    [property: string]: any;
}

/**
 * Statistics for a date data type
 */
export interface DateStats {
    /**
     * Maximum date value as string
     */
    max_date?: string;
    /**
     * Average date value as string
     */
    mean_date?: string;
    /**
     * Sample median (50% value) date value as string
     */
    median_date?: string;
    /**
     * Minimum date value as string
     */
    min_date?: string;
    /**
     * The exact number of distinct values
     */
    num_unique?: number;
    [property: string]: any;
}

/**
 * Statistics for a datetime data type
 */
export interface DatetimeStats {
    /**
     * Maximum date value as string
     */
    max_date?: string;
    /**
     * Average date value as string
     */
    mean_date?: string;
    /**
     * Sample median (50% value) date value as string
     */
    median_date?: string;
    /**
     * Minimum date value as string
     */
    min_date?: string;
    /**
     * The exact number of distinct values
     */
    num_unique?: number;
    /**
     * Time zone for timestamp with time zone
     */
    timezone?: string;
    [property: string]: any;
}

/**
 * Statistics for a numeric data type
 */
export interface NumberStats {
    /**
     * Maximum value as string
     */
    max_value?: string;
    /**
     * Average value as string
     */
    mean?: string;
    /**
     * Sample median (50% value) value as string
     */
    median?: string;
    /**
     * Minimum value as string
     */
    min_value?: string;
    /**
     * Sample standard deviation as a string
     */
    stdev?: string;
    [property: string]: any;
}

/**
 * Summary statistics for any other data types
 */
export interface OtherStats {
    /**
     * The number of unique values
     */
    num_unique?: number;
    [property: string]: any;
}

/**
 * Statistics for a string-like data type
 */
export interface StringStats {
    /**
     * The number of empty / length-zero values
     */
    num_empty: number;
    /**
     * The exact number of distinct values
     */
    num_unique: number;
    [property: string]: any;
}

/**
 * A union of different selection types for column values
 */
export interface ColumnSelection {
    /**
     * Column index (relative to unfiltered schema) to select data from
     */
    column_index: number;
    /**
     * Union of selection specifications for array_selection
     */
    spec: ArraySelection;
    [property: string]: any;
}

export interface ConvertToCodeParams {
    /**
     * The name of the code syntax, eg, pandas, polars, dplyr, etc.
     */
    code_syntax_name: string;
    column_filters:   ColumnFilterElement[];
    row_filters:      RowFilterElement[];
    sort_keys:        ColumnSortKeyElement[];
    [property: string]: any;
}

/**
 * Code snippet for the data view
 */
export interface ConvertedCode {
    /**
     * Lines of code that implement filters and sort keys
     */
    converted_code: string[];
    [property: string]: any;
}

/**
 * A rectangular cell selection defined by arrays of row and column indices
 */
export interface DataSelectionCellIndicesObject {
    /**
     * The selected column indices
     */
    column_indices: number[];
    /**
     * The selected row indices
     */
    row_indices: number[];
    [property: string]: any;
}

/**
 * A selection that contains a rectangular range of data cells
 */
export interface DataSelectionCellRangeObject {
    /**
     * The starting selected column index (inclusive)
     */
    first_column_index: number;
    /**
     * The starting selected row index (inclusive)
     */
    first_row_index: number;
    /**
     * The final selected column index (inclusive)
     */
    last_column_index: number;
    /**
     * The final selected row index (inclusive)
     */
    last_row_index: number;
    [property: string]: any;
}

/**
 * A selection defined by a sequence of indices to include
 */
export interface DataSelectionIndicesObject {
    /**
     * The selected indices
     */
    indices: number[];
    [property: string]: any;
}

/**
 * A contiguous selection bounded by inclusive start and end indices
 */
export interface DataSelectionRangeObject {
    /**
     * The starting selected index (inclusive)
     */
    first_index: number;
    /**
     * The final selected index (inclusive)
     */
    last_index: number;
    [property: string]: any;
}

/**
 * A selection that contains a single data cell
 */
export interface DataSelectionSingleCellObject {
    /**
     * The selected column index
     */
    column_index: number;
    /**
     * The selected row index
     */
    row_index: number;
    [property: string]: any;
}

/**
 * Import options for file-based data sources. Currently supports options for delimited text
 * files (CSV, TSV).
 */
export interface DatasetImportOptions {
    /**
     * Whether the first row contains column headers (for delimited text files)
     */
    has_header_row?: boolean;
    [property: string]: any;
}

export interface ExportDataSelectionParams {
    format:    ExportFormatElement;
    selection: TableSelectionObject;
    [property: string]: any;
}

/**
 * A selection on the data grid, for copying to the clipboard or other actions
 */
export interface TableSelectionObject {
    /**
     * Type of selection, all indices relative to filtered row/column indices
     */
    kind: Kind;
    /**
     * A union of selection types
     */
    selection: TableSelectionSelection;
    [property: string]: any;
}

/**
 * Type of selection, all indices relative to filtered row/column indices
 */
export enum Kind {
    CellIndices = "cell_indices",
    CellRange = "cell_range",
    ColumnIndices = "column_indices",
    ColumnRange = "column_range",
    RowIndices = "row_indices",
    RowRange = "row_range",
    SingleCell = "single_cell",
}

/**
 * A union of selection types
 *
 * A selection that contains a single data cell
 *
 * A selection that contains a rectangular range of data cells
 *
 * A rectangular cell selection defined by arrays of row and column indices
 *
 * A contiguous selection bounded by inclusive start and end indices
 *
 * A selection defined by a sequence of indices to include
 */
export interface TableSelectionSelection {
    /**
     * The selected column index
     */
    column_index?: number;
    /**
     * The selected row index
     */
    row_index?: number;
    /**
     * The starting selected column index (inclusive)
     */
    first_column_index?: number;
    /**
     * The starting selected row index (inclusive)
     */
    first_row_index?: number;
    /**
     * The final selected column index (inclusive)
     */
    last_column_index?: number;
    /**
     * The final selected row index (inclusive)
     */
    last_row_index?: number;
    /**
     * The selected column indices
     */
    column_indices?: number[];
    /**
     * The selected row indices
     */
    row_indices?: number[];
    /**
     * The starting selected index (inclusive)
     */
    first_index?: number;
    /**
     * The final selected index (inclusive)
     */
    last_index?: number;
    /**
     * The selected indices
     */
    indices?: number[];
    [property: string]: any;
}

/**
 * Exported result
 */
export interface ExportedData {
    /**
     * Exported data as a string suitable for copy and paste
     */
    data: string;
    /**
     * The exported data format
     */
    format: ExportFormatElement;
    [property: string]: any;
}

/**
 * Parameters for the 'between' and 'not_between' filter types
 */
export interface FilterBetweenObject {
    /**
     * The lower limit for filtering
     */
    left_value: string;
    /**
     * The upper limit for filtering
     */
    right_value: string;
    [property: string]: any;
}

/**
 * Parameters for the 'compare' filter type
 */
export interface FilterComparisonObject {
    /**
     * String representation of a binary comparison
     */
    op: Op;
    /**
     * A stringified column value for a comparison filter
     */
    value: string;
    [property: string]: any;
}

/**
 * Parameters for the 'match_data_types' filter type
 */
export interface FilterMatchDataTypesObject {
    /**
     * Column display types to match
     */
    display_types: ColumnDisplayTypeElement[];
    [property: string]: any;
}

/**
 * The result of applying filters to a table
 */
export interface FilterResult {
    /**
     * Flag indicating if there were errors in evaluation
     */
    had_errors?: boolean;
    /**
     * Number of rows in table after applying filters
     */
    selected_num_rows: number;
    [property: string]: any;
}

/**
 * Parameters for the 'set_membership' filter type
 */
export interface FilterSetMembershipObject {
    /**
     * Filter by including only values passed (true) or excluding (false)
     */
    inclusive: boolean;
    /**
     * Array of values for a set membership filter
     */
    values: string[];
    [property: string]: any;
}

/**
 * Parameters for the 'search' filter type
 */
export interface FilterTextSearchObject {
    /**
     * If true, do a case-sensitive search, otherwise case-insensitive
     */
    case_sensitive: boolean;
    /**
     * Type of search to perform
     */
    search_type: TextSearchTypeEnum;
    /**
     * String value/regex to search for
     */
    term: string;
    [property: string]: any;
}

/**
 * Formatting options for returning data values as strings
 */
export interface FormatOptions {
    /**
     * Fixed number of decimal places to display for numbers over 1, or in scientific notation
     */
    large_num_digits: number;
    /**
     * Maximum number of integral digits to display before switching to scientific notation
     */
    max_integral_digits: number;
    /**
     * Maximum size of formatted value, for truncating large strings or other large formatted
     * values
     */
    max_value_length: number;
    /**
     * Fixed number of decimal places to display for small numbers, and to determine lower
     * threshold for switching to scientific notation
     */
    small_num_digits: number;
    /**
     * Thousands separator string
     */
    thousands_sep?: string;
    [property: string]: any;
}

export interface GetColumnProfilesParams {
    callback_id:    string;
    format_options: FormatOptions;
    profiles:       ColumnProfileRequest[];
    [property: string]: any;
}

export interface GetDataValuesParams {
    columns:        ColumnSelection[];
    format_options: FormatOptions;
    [property: string]: any;
}

export interface GetRowLabelsParams {
    format_options: FormatOptions;
    selection:      ArraySelection;
    [property: string]: any;
}

export interface GetSchemaParams {
    column_indices: number[];
    [property: string]: any;
}

export interface OpenDatasetParams {
    uri: string;
    [property: string]: any;
}

export interface OpenDatasetResult {
    /**
     * An error message if opening the dataset failed
     */
    error_message?: string;
    [property: string]: any;
}

export interface SearchSchemaParams {
    filters:     ColumnFilterElement[];
    sort_order?: SortOrder;
    [property: string]: any;
}

export enum SortOrder {
    AscendingName = "ascending_name",
    AscendingType = "ascending_type",
    DescendingName = "descending_name",
    DescendingType = "descending_type",
    Original = "original",
}

export interface SearchSchemaResult {
    /**
     * The column indices that match the search parameters in the indicated sort order.
     */
    matches: number[];
    [property: string]: any;
}

export interface SetColumnFiltersParams {
    filters: ColumnFilterElement[];
    [property: string]: any;
}

export interface SetDatasetImportOptionsParams {
    options: DatasetImportOptions;
    [property: string]: any;
}

/**
 * Result of setting import options
 */
export interface SetDatasetImportOptionsResult {
    /**
     * An error message if setting the options failed
     */
    error_message?: string;
    [property: string]: any;
}

export interface SetRowFiltersParams {
    filters: RowFilterElement[];
    [property: string]: any;
}

export interface SetSortColumnsParams {
    sort_keys: ColumnSortKeyElement[];
    [property: string]: any;
}

/**
 * Table values formatted as strings
 */
export interface TableData {
    /**
     * The columns of data
     */
    columns: Array<Array<number | string>>;
    [property: string]: any;
}

/**
 * Formatted table row labels formatted as strings
 */
export interface TableRowLabels {
    /**
     * Zero or more arrays of row labels
     */
    row_labels: Array<string[]>;
    [property: string]: any;
}

/**
 * The schema for a table-like object
 */
export interface TableSchema {
    /**
     * Schema for each column in the table
     */
    columns: ColumnSchema[];
    [property: string]: any;
}

