import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = join(__dirname, '..');
const schemaPath = join(projectRoot, 'resources', 'sidecar_events.json');
const outputPath = join(projectRoot, 'src', 'ark', 'sidecarProtocol.generated.ts');

function formatLiteral(value) {
    if (typeof value === 'string') {
        return `'${value.replace(/'/g, "\\'")}'`;
    }
    return JSON.stringify(value);
}

function schemaTypeToTs(schema) {
    if (schema.const !== undefined) {
        return formatLiteral(schema.const);
    }
    if (Array.isArray(schema.enum)) {
        return schema.enum.map((item) => formatLiteral(item)).join(' | ');
    }
    if (Array.isArray(schema.type)) {
        return schema.type.map((type) => schemaTypeToTs({ ...schema, type })).join(' | ');
    }
    switch (schema.type) {
        case 'string':
            return 'string';
        case 'integer':
        case 'number':
            return 'number';
        case 'boolean':
            return 'boolean';
        case 'null':
            return 'null';
        case 'object':
            if (schema.additionalProperties) {
                return 'Record<string, unknown>';
            }
            return 'Record<string, never>';
        default:
            return 'unknown';
    }
}

function generateInterface(schema) {
    const title = schema.title || 'SidecarEventVariant';
    const properties = schema.properties ?? {};
    const required = new Set(schema.required ?? []);
    const lines = [`export interface ${title} {`];
    for (const [name, propSchema] of Object.entries(properties)) {
        const optional = required.has(name) ? '' : '?';
        const type = schemaTypeToTs(propSchema);
        lines.push(`    ${name}${optional}: ${type};`);
    }
    lines.push('}');
    return { title, lines };
}

function generate() {
    const schema = JSON.parse(readFileSync(schemaPath, 'utf8'));
    const variants = Array.isArray(schema.oneOf) ? schema.oneOf : [];
    if (variants.length === 0) {
        throw new Error('sidecar_events.json is missing oneOf variants');
    }

    const interfaces = variants.map((variant) => generateInterface(variant));
    const union = interfaces.map((entry) => entry.title).join(' | ');

    const header = [
        '// @generated',
        '// This file is generated by scripts/generate-sidecar-event-types.mjs from resources/sidecar_events.json.',
        '',
        '/**',
        ' * Sidecar event envelope emitted over stdout.',
        ' */',
    ].join('\n');

    const lines = [
        header,
        '',
        ...interfaces.flatMap((entry) => [...entry.lines, '']),
        `export type SidecarEvent = ${union};`,
        '',
    ];

    writeFileSync(outputPath, `${lines.join('\n')}`);
    console.log(`[sidecar] Generated types at ${outputPath}`);
}

try {
    generate();
} catch (error) {
    console.error('[sidecar] Failed to generate types:', error);
    process.exit(1);
}
