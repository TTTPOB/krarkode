import { readFileSync, writeFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import { createRequire } from 'module';

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = join(__dirname, '..');
const schemaPath = join(projectRoot, 'resources', 'data_explorer.json');
const outputPath = join(projectRoot, 'src', 'dataExplorer', 'protocol.generated.ts');

const require = createRequire(import.meta.url);
const { quicktype, InputData, JSONSchemaInput, FetchingJSONSchemaStore } = require('quicktype-core');

async function generate() {
    const openrpc = JSON.parse(readFileSync(schemaPath, 'utf8'));
    const schemaMap = openrpc?.components?.schemas;
    if (!schemaMap || typeof schemaMap !== 'object') {
        throw new Error('Missing components.schemas in resources/data_explorer.json');
    }

    const methodSchemas = new Map();
    const methods = Array.isArray(openrpc?.methods) ? openrpc.methods : [];
    for (const method of methods) {
        const schema = method?.result?.schema;
        if (!schema || typeof schema !== 'object') {
            continue;
        }
        const name = schema.name;
        if (!name || typeof name !== 'string') {
            continue;
        }
        methodSchemas.set(name, schema);
    }

    const definitions = { ...schemaMap };
    for (const [name, schema] of methodSchemas.entries()) {
        if (!definitions[name]) {
            definitions[name] = schema;
            continue;
        }
        if (name === 'code_syntax_name') {
            definitions['code_syntax_name_result'] = schema;
        }
    }

    for (const method of methods) {
        if (!method?.name || typeof method.name !== 'string') {
            continue;
        }
        const params = Array.isArray(method.params) ? method.params : [];
        if (params.length === 0) {
            continue;
        }
        const properties = {};
        const required = [];
        for (const param of params) {
            if (!param?.name || typeof param.name !== 'string' || !param.schema) {
                continue;
            }
            properties[param.name] = param.schema;
            if (param.required) {
                required.push(param.name);
            }
        }
        if (Object.keys(properties).length === 0) {
            continue;
        }
        const paramSchemaName = `${method.name}_params`;
        if (!definitions[paramSchemaName]) {
            const schema = {
                type: 'object',
                properties,
            };
            if (required.length > 0) {
                schema.required = required;
            }
            definitions[paramSchemaName] = schema;
        }
    }

    const schemaNames = Object.keys(definitions).sort();
    const orderedDefinitions = Object.fromEntries(schemaNames.map((name) => [name, definitions[name]]));
    const properties = Object.fromEntries(schemaNames.map((name) => [name, { $ref: `#/components/schemas/${name}` }]));
    const schema = {
        $schema: 'http://json-schema.org/draft-07/schema#',
        title: 'DataExplorerTypes',
        type: 'object',
        properties,
        components: {
            schemas: orderedDefinitions,
        },
    };

    const schemaInput = new JSONSchemaInput(new FetchingJSONSchemaStore());
    await schemaInput.addSource({ name: 'DataExplorerTypes', schema: JSON.stringify(schema) });

    const inputData = new InputData();
    inputData.addInput(schemaInput);

    const { lines } = await quicktype({
        inputData,
        lang: 'ts',
        rendererOptions: {
            'just-types': 'true',
        },
    });

    const header = [
        '// @generated',
        '// This file is generated by scripts/generate-data-explorer-types.mjs from resources/data_explorer.json.',
        '',
    ].join('\n');

    writeFileSync(outputPath, `${header}${lines.join('\n')}\n`);
    console.log(`[data-explorer] Generated types at ${outputPath}`);
}

generate().catch((error) => {
    console.error('[data-explorer] Failed to generate types:', error);
    process.exit(1);
});
